#!/usr/bin/env python

import os
import subprocess
import sys

tests_run    = 0
tests_passed = 0
pythonpath = ['./']
testfiles  = []
failfiles  = 0

def test_script_fail_abort(f, results):
    print(results[1])
    print(">>> ABORT: Test script {} ended with nonzero status ({}); halting test run".format(f, results[0]))
    sys.exit(1)

# walk pwd tree
print("Begin run: searching for modules and tests.")
for root, dirs, files in os.walk("."):
    for f in sorted(files):
        if f[-3:] == ".py":
            if root[-6:] == "/tests":
                testfiles.append(os.path.join(root,f))
            else:
                pythonpath.append(os.path.join(root,f))

# build the PYTHONPATH value
pypathstr = ":".join(pythonpath)

# run each test found
for test in testfiles:
    print("   Running {} - ".format(test), end='') 
    results = subprocess.getstatusoutput("PYTHONPATH=\"{}\" /usr/bin/env python {}".format(pypathstr, test))
    # abort if the test script as a whole failed
    if results[0] != 0:
        test_script_fail_abort(test, results)
    # script was ok. pull test counts off results
    reslist = results[1].split("\n")
    trun, tpass = reslist[-1].split();
    reslist.pop()
    # tell about success or failure
    if trun == tpass:
        print("{}/{} passing; ok".format(tpass, trun))
    else:
        print("{}/{} passing; FAIL".format(tpass, trun))
        failfiles += 1
    # print errors, if any
    if len(reslist) > 0:
        print("\n".join(["      " + line for line in reslist]))
    # print script summary and add to totals
    tests_run += int(trun)
    tests_passed += int(tpass)

if len(testfiles) > 0:
    print("End of run")
    print("   Tests passing: {}/{}, in {} script(s)".format(tests_passed, tests_run, len(testfiles)))
    tests_failed = tests_run - tests_passed
    if tests_failed > 0:
        print("   Tests failing:   {}, in {} script(s)".format(tests_failed, failfiles))
        print(">>FAIL<<")
    else:
        print("Success")
else:
    print("No tests found; nothing to do.")
